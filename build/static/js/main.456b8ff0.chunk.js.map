{"version":3,"sources":["ShowTime.js","Todolist/Todoinput.js","Todolist/Todoing.js","Todolist/Todolist.js","Request.js","index.js"],"names":["Component","Todoinput","handleInput","e","keyCode","props","addTodo","target","value","handleChange","setState","name","parseInt","state","n1","n2","style","color","this","fontSize","htmlFor","id","onChange","onKeyDown","type","dangerouslySetInnerHTML","__html","Todoing","a","className","todo","map","item","idx","key","onClick","delTodo","defaultProps","arr","console","log","b","JSON","parse","stringify","o","Object","assign","keys","forEach","Request","data","fetch","then","res","json","result","index","album_title","author","ReactDOM","render","document","getElementById","React","createElement"],"mappings":"0PAOuBA,Y,cC2BFC,E,YACjB,aAAc,IAAD,8BACT,+CAOJC,YAAc,SAACC,GACM,KAAdA,EAAEC,SACD,EAAKC,MAAMC,QAAQH,EAAEI,OAAOC,QAVvB,EAcbC,aAAe,SAACN,GACZ,EAAKO,SAAL,eACKP,EAAEI,OAAOI,KAAMC,SAAyB,IAAhBT,EAAEI,OAAOC,MAAY,EAAIL,EAAEI,OAAOC,UAd/D,EAAKK,MAAM,CAEPC,GAAG,EACHC,GAAG,GALE,E,sEAmBH,IAAD,OACL,OACI,6BACI,2BAAOC,MAAO,CAACC,MAAMC,KAAKL,MAAMC,GAAGI,KAAKL,MAAME,GAAG,GAAK,MAAQ,QAAQI,SAAS,QAASC,QAAQ,OAAhG,sBACA,2BAAOC,GAAG,MAAMV,KAAK,KAAKW,SAAU,SAACnB,GAAD,OAAK,EAAKM,aAAaN,IAAIK,MAAOU,KAAKL,MAAMC,GAAIS,UAAWL,KAAKhB,YAAasB,KAAK,SAF3H,IAII,2BAAOb,KAAK,KAAKW,SAAUJ,KAAKT,aAAcD,MAAOU,KAAKL,MAAME,GAAIQ,UAAWL,KAAKhB,YAAasB,KAAK,SACtG,uBAAGC,wBAAyB,CAACC,OAAOR,KAAKL,MAAMC,GAAGI,KAAKL,MAAME,MAC7D,qD,GA5BuBf,aC9BlB2B,E,iLACP,IAAD,OACL,OACI,6BACI,uDAAST,KAAKb,MAAMuB,GACpB,wBAAIC,UAAU,QAGNX,KAAKb,MAAMyB,KAAKC,KAAI,SAACC,EAAKC,GAAN,OAAY,wBAAIC,IAAKD,GAAMD,EAAf,QAAyB,4BAAQG,QAAS,WAAK,EAAK9B,MAAM+B,QAAQH,KAAzC,0B,GAR5CjC,aAmBrC2B,EAAQU,aAAa,CACjBP,KAAK,CAAC,EAAE,EAAE,GACVF,EAAE,KCpBgC5B,Y,IA4ClCsC,EAAM,CAAC,EAAE,EAAE,CAACV,EAAE,MACX,UAAOU,GACVV,EAAI,IACRW,QAAQC,IAAIF,IAGRG,EAAIC,KAAKC,MAAMD,KAAKE,UAAUN,KAChC,GAAGV,EAAI,IACTW,QAAQC,IAAIF,GAIZ,IAAIV,EAAI,CAACA,EAAE,KACPa,EAAI,CAACA,EAAE,KACPI,EAAIC,OAAOC,OAAOnB,EAAEa,GACxBF,QAAQC,IAAIK,IAAIjB,GAEZA,EAAI,CAACA,EAAE,KACPiB,EAAIC,OAAOC,OAAO,GAAGnB,GAazB,IAAI,IAAII,KAZRO,QAAQC,IAAIK,IAAIjB,GAChBW,QAAQC,IAAIK,GAIZC,OAAOE,KAAKpB,GAAGqB,SAAQ,SAACjB,GACpBO,QAAQC,IAAIR,GACZO,QAAQC,IAAIZ,EAAEI,OAKFJ,EACZW,QAAQC,IAAIZ,G,UC5EKsB,E,YACjB,aAAc,IAAD,8BACT,+CACKrC,MAAQ,CACTsC,KAAK,IAHA,E,iFAMO,IAAD,OAEfC,MAAM,uDACDC,MAAK,SAACC,GACH,OAAOA,EAAIC,UAEdF,MAAK,SAACC,GACH,EAAK5C,SAAS,CACVyC,KAAKG,EAAIE,SAEbjB,QAAQC,IAAIc,Q,+BAcpB,OACI,6BACI,wDACA,4BAEQpC,KAAKL,MAAMsC,KAAKpB,KAAI,SAACC,EAAKyB,GAAN,OAChB,wBAAIvB,IAAKuB,GACL,4BAAKzB,EAAK0B,aACV,2BAAI1B,EAAK2B,kB,GAvCJ3D,aCSrC4D,IAASC,OAAO,kBAAC,EAAD,MAAWC,SAASC,eAAe,SAoCzCC,IAAMC,cACZ,MACA,CAAC,GAAK,OACN,QACAD,IAAMC,cACF,KACA,CAAC,GAAK,KACN,Y","file":"static/js/main.456b8ff0.chunk.js","sourcesContent":["/**\r\n * 父组件\r\n */\r\n\r\nimport React,{Component,Fragment} from 'react';\r\n\r\n//用类定义组件\r\nclass ShowTime extends Component{\r\n    //construtor只会执行一次\r\n    constructor(){\r\n        super();//将父类中的this对象继承给子类\r\n        this.state = {\r\n            time:new Date().toLocaleString()\r\n        }\r\n        // this.handleClick = this.handleClick.bind(this);\r\n    }\r\n\r\n    componentDidMount(){\r\n        console.log('componentDidMount');\r\n        setTimeout(() => {\r\n            console.log(1);\r\n            this.setState({\r\n                time: new Date().toLocaleString()\r\n            })\r\n        },1000);\r\n    }\r\n\r\n    shouldComponentUpdate(){\r\n        return true;\r\n    }\r\n\r\n    getSnapshotBeforeUpdate(){\r\n        console.log('getsnapshot');\r\n    }\r\n\r\n    componentDidUpdate(){\r\n        console.log('didupdate');\r\n    }\r\n\r\n    //点击事件处理函数\r\n    //内容较多时，在外面封装，并在标签处绑定\r\n    //内容较少时，在标签绑定的事件上写一个箭头函数即可\r\n    handleClick = (num,e)=>{\r\n        console.log(num,e);\r\n        console.log('点击成功');\r\n    }\r\n\r\n    divClick(num,e){\r\n        console.log(num,e);\r\n    }\r\n\r\n\r\n    //每执行一次setState就会执行一次render\r\n    render(){\r\n        console.log('render');\r\n        return(\r\n            <Fragment>\r\n                {/* 箭头函数是事件处理函数，handleClick并不是事件处理函数，它只是一个普通的函数 */}\r\n                <div onClick={(ev)=>this.handleClick(2,ev)}>{this.state.time}</div>\r\n                <div onClick={this.divClick.bind(this,3)}>hello{this.props.word}</div>\r\n            </Fragment>\r\n        )\r\n    }\r\n}\r\n\r\n//默认导出,只能导出一次，名儿随便起一般用组件名\r\nexport default ShowTime;\r\n//另一种写法,在类定义组件的时候：export default class ShowTime extends Component{};\r\n\r\n//命名导出,可以导出多个；\r\n//export {ShowTime};\r\n//export {x};\r\n//export {xx};\r\n//export {xxx};\r\n//注意：index.js中引入的时候：import {ShowTime} from './ShowTime';","import React, { Component } from 'react'\r\n//子组件-->父组件传递数据，调用子组件时往子组件传递一个函数\r\n//子组件通过props调用该函数\r\n\r\n//受控组件和非受控组件\r\n\r\n/*\r\n//非受控组件\r\n//代码简单、比较适用于一次性获取表单的值\r\nexport default class Todoinput extends Component{\r\n    componentDidMount(){  //此函数在render函数执行之后才执行\r\n        console.log(this.inp.value);\r\n        // console.log(this);\r\n    }\r\n    search=()=>{\r\n        console.log(this.inp.value);\r\n    }\r\n    render(){\r\n        return (\r\n            <div>\r\n                //获取节点的方式:回调函数 \r\n                <input ref={(inp)=>this.inp=inp} type=\"text\"/>\r\n                <button onClick={this.search}>查询</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n*/\r\n\r\n\r\n\r\n//受控组件：value值被react的状态控制\r\n//可以方便拿到input框的值、实时获取数据或实时处理输入的内容\r\n\r\nexport default class Todoinput extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            // val:111\r\n            n1:0,\r\n            n2:0\r\n        }\r\n    }\r\n    handleInput = (e)=>{\r\n        if(e.keyCode === 13){\r\n            this.props.addTodo(e.target.value)\r\n        }\r\n    }\r\n    //无需传参时，这就是事件处理函数；需要传参时，用一个箭头函数做事件处理函数\r\n    handleChange = (e)=>{\r\n        this.setState({\r\n            [e.target.name]:parseInt(e.target.value=='' ? 0 : e.target.value)\r\n        })\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <label style={{color:this.state.n1+this.state.n2>10 ? 'red' : 'green',fontSize:'25px'}} htmlFor=\"inp\">输入：</label>\r\n                <input id=\"inp\" name=\"n1\" onChange={(e)=>this.handleChange(e)} value={this.state.n1} onKeyDown={this.handleInput} type=\"text\"/>\r\n                +\r\n                <input name=\"n2\" onChange={this.handleChange} value={this.state.n2} onKeyDown={this.handleInput} type=\"text\"/>\r\n                <p dangerouslySetInnerHTML={{__html:this.state.n1+this.state.n2}}></p>\r\n                <button>查询</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import React, { Component } from 'react'\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\nexport default class Todoing extends Component {\r\n    render() {\r\n        return (\r\n            <div>\r\n                <h1>正在进行{this.props.a}</h1>\r\n                <ul className=\"list\">\r\n                    {/* 数组常用方法:arr.forEach\\some\\every\\find\\map\\reduce */}\r\n                    {\r\n                        this.props.todo.map((item,idx)=><li key={idx}>{item}-----<button onClick={()=>{this.props.delTodo(idx)}}>删除</button></li>)\r\n                    }\r\n                </ul>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nTodoing.propTypes = {\r\n    todo:PropTypes.array\r\n}\r\nTodoing.defaultProps={\r\n    todo:[2,3,4],\r\n    a:100\r\n}","import React,{Component} from 'react';\r\nimport Todoinput from './Todoinput';\r\nimport Todoing from './Todoing';\r\n\r\n\r\nexport default class Todolist extends Component{\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            todo:[1,2,3]\r\n        }\r\n    }\r\n    addItem = (msg)=>{\r\n        // this.state.todo.push(msg);\r\n        // console.log(this.state.todo);\r\n        this.setState({\r\n            todo:[...this.state.todo,msg]\r\n        })\r\n        // console.log(msg);\r\n    }\r\n    delitem = (a)=>{\r\n        // this.state.todo.splice(a,1);\r\n        //深拷贝\\浅拷贝\r\n        //状态（state）：\r\n        // 1.不要直接改变、处理状态\r\n        var todo =[...this.state.todo];\r\n        todo.splice(a,1);\r\n\r\n        //2.setState是异步的\r\n\r\n        this.setState({\r\n            todo\r\n        })\r\n        console.log(a);\r\n    }\r\n\r\n    render(){\r\n        return(\r\n            <div>\r\n                <Todoinput addTodo={this.addItem}/>\r\n                <Todoing delTodo={this.delitem} todo={this.state.todo}/>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n\r\n\r\n//浅拷贝\r\nvar arr = [1,2,{a:100}];\r\nvar brr = [...arr];\r\nbrr.a = 200;\r\nconsole.log(arr);\r\n\r\n//深拷贝\r\nvar b = JSON.parse(JSON.stringify(arr));\r\nb[2].a = 200;\r\nconsole.log(arr);\r\n\r\n\r\n//对象的拷贝\r\nvar a = {a:100};\r\nvar b = {b:200};\r\nvar o = Object.assign(a,b);\r\nconsole.log(o===a);\r\n\r\nvar a = {a:100};\r\nvar o = Object.assign({},a);\r\nconsole.log(o===a);\r\nconsole.log(o);\r\n\r\n\r\n//Object.keys返回由所有属性名组成的一个数组\r\nObject.keys(a).forEach((item)=>{\r\n    console.log(item);\r\n    console.log(a[item]);\r\n})\r\n\r\n//尽量不用for var in\r\n//原型上的东西也会被遍历出来\r\nfor(var item in a){\r\n    console.log(a);\r\n}","//分封装Request组件：\r\n\r\nimport React, { Component } from 'react'\r\nimport Axios from 'axios';\r\n//用类定义组件\r\nexport default class Request extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state = { \r\n            data:[]\r\n        }\r\n    }\r\n    componentDidMount(){\r\n        //发起请求\r\n        fetch('https://api.apiopen.top/musicRankingsDetails?type=1')\r\n            .then((res)=>{\r\n                return res.json();\r\n            })\r\n            .then((res)=>{\r\n                this.setState({\r\n                    data:res.result\r\n                })\r\n                console.log(res);\r\n            })\r\n\r\n        /*\r\n        Axios.get('https://api.apiopen.top/musicRankingsDetails?type=1')\r\n        .then((res)=>{\r\n            console.log(res);\r\n            this.setState({\r\n                data:res.data.result\r\n            })\r\n        })\r\n        */\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <h1>请求接口</h1>\r\n                <ul>\r\n                    {\r\n                        this.state.data.map((item,index)=>(\r\n                            <li key={index}>\r\n                                <h2>{item.album_title}</h2>\r\n                                <p>{item.author}</p>\r\n                            </li>\r\n                            )\r\n                        )\r\n                    }   \r\n                </ul>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","//引入库、组件\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport ShowTime from './ShowTime';\nimport Todolist from './Todolist/Todolist';\nimport Request from './Request';\n\n//组件交互\n//父组件--->子组件：在子组件上添加属性\n//在子组件中通过props获取数据\n\n// ReactDOM.render(<ShowTime word=\"react\"/>,document.getElementById('root'));\n// ReactDOM.render(<Todolist/>,document.getElementById('root'));\nReactDOM.render(<Request/>,document.getElementById('root'));\n\n\n// var e = <div>hello</div>;\n// ReactDOM.render(e,document.getElementById('root'));\n\n\n// function tick(){\n//     var e = <div>{new Date().toLocaleString()}</div>\n//     ReactDOM.render(e,document.getElementById('root'));\n// }\n// tick();\n\n//用函数定义的组件(无生命周期函数)\n//当只是渲染结构时\nfunction ToDo(props){\n    return (\n        <div>\n            {/* 条件渲染 */}\n            {props.list.length >=5 ? <h1>toDo</h1> : ''}\n            {/* {props.list.length >=6 && <h1>toDo</h1>} */}\n            <ul>\n                {/* 循环渲染 */}\n                {\n                    props.list.map((item,index) => index%2 == 0 && <li key={item}>{item}</li>)\n                }\n            </ul>\n        </div>\n    )\n}\nvar item = [1,2,3,4,5];\n// ReactDOM.render(<ToDo list={item}/>,document.getElementById('root'));\n\n\n\n/**jsx表达式会被react转换成一个对象*/\nvar ele = React.createElement(\n    'div',\n    {\"id\":\"box\"},\n    'hello',\n    React.createElement(\n        'h1',\n        {'id':'h'},\n        'react',\n    )\n);\n\nvar obj = {\n    type:'div',\n    props:{\n        id:'box',\n        class:'box',\n        children:['hello',{\n            type:'h1',\n            props:{\n                id:'h',\n                class:'h',\n                children:['react']\n            }\n        }]\n    }\n}\n\n//加载html文件、浏览器解析html生成DOM树    <======>  对应页面回流\n//link加载css文件、解析css规则、和DOM树结合生成render树，浏览器渲染引擎渲染render树   <======>  对应页面重绘\n//页面回流一定会引起页面重绘\n//页面回流（页面重排）：内容改变、大小改变、结构改变\n//页面重绘：改变字体颜色、背景颜色等样式\n\n\n/*\n * 用以下这种方法会使浏览器（页面）执行1000次回流\n   for(var i = 0;i<1000;i++){\n      document.body.innerHTML += '<li>'+i+'</li>';\n   }\n*/\n\n/**\n * 以下是正确的方法：\n   var str ='';\n   for(var i=0;i<1000;i++){\n       str += '<li>'+i+'</li>';\n   }\n   document.body.innerHTML = str;//仅在此回流一次\n*/\n\n\n/* \n * 同样的，\n   display、width、height、font-size等样式的改变也会引起页面回流\n   document.body.style.width = '100px';//回流1次\n   document.body.style.height = '100px';//回流1次\n*/\n\n/**\n * 以下是正确的方法，声明一个css的类：\n    .change{\n        width:100px;\n        height:100px;\n    }\n * document.body.className = 'change';\n */\n\n\n/*\n * 同样的，\n   页面中的node.offsetLeft、node.offsetWidth等慎用 \n    var root = document.getElementById('root');\n    setInterval(function(){\n        root.style.width = root.offsetWidth + 1 +'px';\n    },100);\n*/\n\n/*\n * 以下是正确的方法：对节点的操作先用变量代替\n    var root = document.getElementById('root');\n    var width = root.offsetWidth;\n    setInterval(function(){\n        width += 1;\n        root.style.width = width +'px';\n    },100);\n*/\n\n//自己声明的render函数，实现页面渲染\nfunction render(obj,container){\n    var ele = document.createElement(obj.type);\n    /*\n    不灵活，只能死板的改\n    ele.id = obj.props.id;\n    ele.innerHTML = obj.props.children[0];\n    */\n\n    //文档碎片(对应操作的是一个内存空间)\n    var fragment = document.createDocumentFragment();\n\n    var {type,props} = obj;\n    for(var item in props){\n        if(item === 'class'){\n            ele.className = props[item];\n        }else if(item === 'children'){\n            for(var i=0;i<props[item].length;i++){\n                if(typeof props[item][i]==='object'){\n                    render(props[item][i],ele);\n                }\n                else{\n                    var txt = document.createTextNode(props[item][i]);\n                    ele.appendChild(txt);\n                }\n            }\n        }else{\n            ele[item] = props[item];\n        }\n    }\n\n    fragment.appendChild(ele);\n    container.appendChild(fragment);\n}\n\n// render(obj,document.getElementById('root'));\n\n// ReactDOM.render(ele, document.getElementById('root'));"],"sourceRoot":""}